generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model AuthSession {
  key     String @id
  session String
}

model AuthState {
  key   String @id
  state String
}

enum MirrorStatus {
  Dirty
  InProcess
  Sync
  Failed
}

model User {
  did         String  @id @db.VarChar(255) // https://atproto.com/guides/identity
  handle      String?
  displayName String?
  avatar      String?
  banner      String?
  email       String?
  description String?

  hasAccess    Boolean @default(false) // si tiene o no acceso al período de prueba
  inCA         Boolean @default(false)
  CAProfile    Record? @relation("CAProfile", fields: [CAProfileUri], references: [uri])
  CAProfileUri String? @unique

  mirrorStatus MirrorStatus @default(Dirty) // estado del mirror, usado en atproto-sync

  createdAt DateTime @default(now()) @map("created_at")

  editorStatus  EditorStatus @default(Beginner) // permisos de editor en la wiki
  platformAdmin Boolean      @default(false) // si tiene acceso o no a /admin

  subscriptionsBought Subscription[] @relation("bought")
  subscriptionsUsed   Subscription[]

  messagesSent     ChatMessage[] @relation("messagesSent")
  messagesReceived ChatMessage[] @relation("messagesReceived")

  paymentPromises PaymentPromise[] @relation("authorPromises")

  views   View[]
  records Record[]
  blobs   Blob[]

  followers Follow[]

  usedInviteCode InviteCode?  @relation("invite-code-used")
  recommendCodes InviteCode[] @relation("invite-codes-available") // los códigos de invitación que tiene disponibles para usar

  seenTutorial Boolean @default(false)
}

model InviteCode {
  code      String    @id @default(cuid())
  usedBy    User?     @relation("invite-code-used", fields: [usedByDid], references: [did])
  usedByDid String?   @unique
  usedAt    DateTime?

  recommender   User?   @relation("invite-codes-available", fields: [recommenderId], references: [did])
  recommenderId String? @unique
}

model Subscription {
  id             String    @id @default(cuid())
  userId         String?
  createdAt      DateTime  @default(now()) @map("created_at")
  boughtByUserId String
  usedAt         DateTime?
  boughtBy       User      @relation("bought", fields: [boughtByUserId], references: [did])
  user           User?     @relation(fields: [userId], references: [did])
  price          Int
  paymentId      String?
  endsAt         DateTime?

  paymentPromises PaymentPromise[]
  promisesCreated Boolean          @default(false)
}

enum PromiseStatus {
  Pending
  Confirmed
  Canceled
}

model PaymentPromise {
  id String @id @default(cuid())

  createdAt DateTime @default(now()) @map("created_at")

  author   User   @relation("authorPromises", fields: [authorId], references: [did])
  authorId String

  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  amount Float // errores numéricos?

  contentUri String

  status PromiseStatus @default(Pending) // true cuando el contenido pasó su período de gracia
}

model Topic {
  id                 String            @id
  protection         EditorStatus      @default(Beginner)
  versions           TopicVersion[]
  currentVersion     TopicVersion?     @relation("currentVersion", fields: [currentVersionId], references: [uri])
  currentVersionId   String?           @unique
  referencedBy       Reference[]
  synonyms           String[]
  categories         TopicToCategory[]
  lastSynonymsChange DateTime?
  popularityScore    Int?
  lastEdit           DateTime?
}

model TopicCategory {
  id     String            @id
  topics TopicToCategory[]
  linksA CategoryLink[]    @relation("linksA")
  linksB CategoryLink[]    @relation("linksB")
}

model CategoryLink {
  idCategoryA String
  categoryA   TopicCategory @relation("linksA", fields: [idCategoryA], references: id)
  idCategoryB String
  categoryB   TopicCategory @relation("linksB", fields: [idCategoryB], references: id)

  @@id([idCategoryA, idCategoryB])
}

model TopicToCategory {
  topicId    String
  categoryId String

  topic    Topic         @relation(fields: [topicId], references: [id])
  category TopicCategory @relation(fields: [categoryId], references: [id])

  @@id([topicId, categoryId])
}

model Record {
  uri        String  @id @unique
  cid        String?
  collection String
  rkey       String

  author   User   @relation(fields: [authorId], references: [did])
  authorId String

  createdAt DateTime @default(now()) @map("created_at")

  content             Content?
  like                Like?
  repost              Repost?
  topicAccept         TopicAccept?
  topicReject         TopicReject?
  follow              Follow?
  dataset             Dataset?
  dataBlock           DataBlock?
  visualization       Visualization?
  visualizationsUsing Visualization[] @relation("visualizationUsesDataset")

  embeddedIn      Record?  @relation("embeddings", fields: [uri], references: [uri])
  embeddedRecords Record[] @relation("embeddings")

  record String?

  likes   Like[]   @relation("likes")
  reposts Repost[] @relation("reposts")
  replies Post[]   @relation("reply")
  rootOf  Post[]   @relation("root")

  accepts TopicAccept[] @relation("accepts")
  rejects TopicReject[] @relation("rejects")

  views            View[]
  uniqueViewsCount Int?   @default(0)

  CAProfileOf User? @relation("CAProfile")

  enDiscusion Boolean @default(false)
}

model Content {
  uri    String @id
  record Record @relation(fields: [uri], references: [uri])

  text       String?
  textBlobId String?
  textBlob   Blob?   @relation(fields: [textBlobId], references: [cid])

  format String @default("lexical-compressed")

  numWords Int?

  topicVersion TopicVersion?
  article      Article?
  post         Post?

  references           Reference[]
  lastReferencesUpdate DateTime?
}

model Post {
  uri     String  @id
  content Content @relation(fields: [uri], references: [uri])

  facets String?
  embed  String?

  replyToId String?
  replyTo   Record? @relation("reply", fields: [replyToId], references: [uri])

  quote String?

  rootId String?
  root   Record? @relation("root", fields: [rootId], references: [uri])
}

model Follow {
  uri            String  @id
  record         Record  @relation(fields: [uri], references: [uri])
  userFollowedId String?
  userFollowed   User?   @relation(fields: [userFollowedId], references: [did])
}

model Like {
  uri           String  @id
  record        Record  @relation(fields: [uri], references: [uri])
  likedRecordId String?
  likedRecord   Record? @relation("likes", fields: [likedRecordId], references: [uri])
}

model Repost {
  uri              String  @id
  record           Record  @relation(fields: [uri], references: [uri])
  repostedRecordId String?
  repostedRecord   Record? @relation("reposts", fields: [repostedRecordId], references: [uri])
}

model TopicAccept {
  uri              String  @id
  record           Record  @relation(fields: [uri], references: [uri])
  acceptedRecordId String?
  acceptedRecord   Record? @relation("accepts", fields: [acceptedRecordId], references: [uri])
}

model TopicReject {
  uri              String  @id
  record           Record  @relation(fields: [uri], references: [uri])
  rejectedRecordId String?
  rejectedRecord   Record? @relation("rejects", fields: [rejectedRecordId], references: [uri])
}

model TopicVersion {
  uri     String  @id
  content Content @relation(fields: [uri], references: [uri])

  title   String?
  topic   Topic   @relation(fields: [topicId], references: [id])
  topicId String
  message String  @default("")

  synonyms   String?
  categories String?

  authorship Boolean @default(true)

  currentVersionOf Topic? @relation("currentVersion")

  charsAdded    Int?
  charsDeleted  Int?
  accCharsAdded Int?
  contribution  String?
  diff          String?
}

model Article {
  uri     String  @id
  content Content @relation(fields: [uri], references: [uri])
  title   String
}

model Dataset {
  uri         String      @id
  record      Record      @relation(fields: [uri], references: [uri])
  columns     String[]
  title       String
  dataBlocks  DataBlock[]
  description String?
}

model Blob {
  cid      String @id @unique
  author   User   @relation(fields: [authorId], references: [did])
  authorId String

  dataBlock DataBlock?
  contentOf Content[]
  previewOf Visualization[]
}

model DataBlock {
  uri       String   @id
  record    Record   @relation(fields: [uri], references: [uri])
  dataset   Dataset? @relation(fields: [datasetId], references: [uri])
  datasetId String?
  format    String
  blob      Blob?    @relation(fields: [blobId], references: [cid])
  blobId    String?  @unique
}

model View {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  userBy    User     @relation(fields: [userById], references: [did])
  userById  String

  recordId String?
  record   Record? @relation(fields: [recordId], references: [uri])
}

model Visualization {
  uri    String @id
  record Record @relation(fields: [uri], references: [uri])

  spec String

  dataset   Record? @relation("visualizationUsesDataset", fields: [datasetId], references: [uri])
  datasetId String?

  previewBlobCid String?
  previewBlob    Blob?   @relation(fields: [previewBlobCid], references: [cid])
}

model Reference {
  id    String        @id @default(uuid())
  type  ReferenceType
  count Int           @default(1)

  referencedTopicId String
  referencedTopic   Topic  @relation(fields: [referencedTopicId], references: [id])

  referencingContentId String
  referencingContent   Content @relation(fields: [referencingContentId], references: [uri])

  @@unique([referencingContentId, referencedTopicId])
}

enum ReferenceType {
  Strong
  Weak
}

model ChatMessage {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now()) @map("created_at")
  fromUser   User     @relation("messagesSent", fields: [fromUserId], references: [did])
  fromUserId String

  toUser   User   @relation("messagesReceived", fields: [toUserId], references: [did])
  toUserId String

  text String

  seen Boolean @default(false)
}

enum EditorStatus {
  Beginner
  Editor
  Administrator
}
