generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model AuthSession {
  key     String @id
  session String
}

model AuthState {
  key   String @id
  state String
}

enum MirrorStatus {
  Dirty
  InProcess
  Sync
  Failed
}

model User {
  did         String  @id @db.VarChar(255) // did
  handle      String?
  displayName String?
  avatar      String?
  banner      String?
  email       String?
  description String?

  hasAccess    Boolean      @default(false)
  inCA         Boolean      @default(false)
  mirrorStatus MirrorStatus @default(Dirty)
  rev          String?

  createdAt DateTime @default(now()) @map("created_at")

  editorStatus EditorStatus @default(Beginner)

  subscriptionsBought Subscription[] @relation("bought")
  subscriptionsUsed   Subscription[]

  messagesSent     ChatMessage[] @relation("messagesSent")
  messagesReceived ChatMessage[] @relation("messagesReceived")

  paymentPromises PaymentPromise[] @relation("authorPromises")

  views   View[]
  records Record[]
  blobs   Blob[]

  followers Follow[]
}

model Subscription {
  id             String    @id @default(cuid())
  userId         String?
  createdAt      DateTime  @default(now()) @map("created_at")
  boughtByUserId String
  usedAt         DateTime?
  boughtBy       User      @relation("bought", fields: [boughtByUserId], references: [did])
  user           User?     @relation(fields: [userId], references: [did])
  price          Int
  paymentId      String?
  endsAt         DateTime?

  paymentPromises PaymentPromise[]
  promisesCreated Boolean          @default(false)
}

enum PromiseStatus {
  Pending
  Confirmed
  Canceled
}

model PaymentPromise {
  id String @id @default(cuid())

  createdAt DateTime @default(now()) @map("created_at")

  author   User   @relation("authorPromises", fields: [authorId], references: [did])
  authorId String

  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  amount Float // errores numéricos?

  contentUri String

  status PromiseStatus @default(Pending) // true cuando el contenido pasó su período de gracia
}

model Topic {
  id               String         @id
  protection       EditorStatus   @default(Beginner)
  versions         TopicVersion[]
  currentVersion   TopicVersion?  @relation("currentVersion", fields: [currentVersionId], references: [uri])
  currentVersionId String?        @unique
  referencedBy     Reference[]
}

model Record {
  uri        String  @id @unique
  cid        String?
  collection String
  rkey       String

  author   User   @relation(fields: [authorId], references: [did])
  authorId String

  createdAt DateTime @default(now()) @map("created_at")

  content             Content?
  reaction            Reaction?
  follow              Follow?
  dataset             Dataset?
  dataBlock           DataBlock?
  visualization       Visualization?
  visualizationsUsing Visualization[] @relation("visualizationUsesDataset")

  embeddedIn      Record?  @relation("embeddings", fields: [uri], references: [uri])
  embeddedRecords Record[] @relation("embeddings")

  record String?

  reactions Reaction[] @relation("reactsTo")
  replies   Post[]     @relation("reply")
  rootOf    Post[]     @relation("root")

  views View[]
}

model Content {
  uri    String @id
  record Record @relation(fields: [uri], references: [uri])

  text       String?
  textBlobId String?
  textBlob   Blob?   @relation(fields: [textBlobId], references: [cid])

  format String @default("lexical-compressed")

  numWords Int?

  topicVersion TopicVersion?
  article      Article?
  post         Post?

  references Reference[]
}

model Post {
  uri     String  @id
  content Content @relation(fields: [uri], references: [uri])

  facets String?
  embed  String?

  replyToId String?
  replyTo   Record? @relation("reply", fields: [replyToId], references: [uri])

  quote String?

  rootId String?
  root   Record? @relation("root", fields: [rootId], references: [uri])
}

model Follow {
  uri            String  @id
  record         Record  @relation(fields: [uri], references: [uri])
  userFollowedId String?
  userFollowed   User?   @relation(fields: [userFollowedId], references: [did])
}

model Reaction {
  uri        String  @id
  record     Record  @relation(fields: [uri], references: [uri])
  reactsToId String?
  reactsTo   Record? @relation("reactsTo", fields: [reactsToId], references: [uri])
}

model TopicVersion {
  uri     String  @id
  content Content @relation(fields: [uri], references: [uri])

  title   String?
  topic   Topic   @relation(fields: [topicId], references: [id])
  topicId String
  message String  @default("")

  synonyms   String?
  categories String?

  authorship Boolean @default(true)

  currentVersionOf Topic? @relation("currentVersion")

  charsAdded    Int?
  charsDeleted  Int?
  accCharsAdded Int?
  contribution  String?
  diff          String?
}

model Article {
  uri     String  @id
  content Content @relation(fields: [uri], references: [uri])
  title   String
}

model Dataset {
  uri        String      @id
  record     Record      @relation(fields: [uri], references: [uri])
  columns    String[]
  title      String
  dataBlocks DataBlock[]
}

model Blob {
  cid      String @id @unique
  author   User   @relation(fields: [authorId], references: [did])
  authorId String

  dataBlock DataBlock?
  contentOf Content[]
  previewOf Visualization[]
}

model DataBlock {
  uri       String   @id
  record    Record   @relation(fields: [uri], references: [uri])
  dataset   Dataset? @relation(fields: [datasetId], references: [uri])
  datasetId String?
  format    String
  blob      Blob?    @relation(fields: [blobId], references: [cid])
  blobId    String?  @unique
}

model View {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  userBy    User     @relation(fields: [userById], references: [did])
  userById  String

  recordId String?
  record   Record? @relation(fields: [recordId], references: [uri])
}

model Visualization {
  uri    String @id
  record Record @relation(fields: [uri], references: [uri])

  spec String

  dataset   Record? @relation("visualizationUsesDataset", fields: [datasetId], references: [uri])
  datasetId String?

  previewBlobCid String?
  previewBlob    Blob?   @relation(fields: [previewBlobCid], references: [cid])
}

model Reference {
  id   String        @id @default(cuid())
  type ReferenceType

  referencedTopicId String
  referencedTopic   Topic  @relation(fields: [referencedTopicId], references: [id])

  referencingContentId String
  referencingContent   Content @relation(fields: [referencingContentId], references: [uri])
}

enum ReferenceType {
  Strong
  Weak
}

model ChatMessage {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now()) @map("created_at")
  fromUser   User     @relation("messagesSent", fields: [fromUserId], references: [did])
  fromUserId String

  toUser   User   @relation("messagesReceived", fields: [toUserId], references: [did])
  toUserId String

  text String

  seen Boolean @default(false)
}

enum EditorStatus {
  Beginner
  Editor
  Administrator
}
