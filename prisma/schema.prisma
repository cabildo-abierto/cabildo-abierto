generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model AuthSession {
  key     String @id
  session String
}

model AuthState {
  key   String @id
  state String
}


model User {
    id                 String         @id @db.VarChar(255) // did
    handle             String
    displayName        String
    description        String
    email              String?

    following          User[]         @relation("following")
    followers          User[]         @relation("following")

    createdAt          DateTime       @default(now()) @map("created_at")

    editorStatus        EditorStatus   @default(Beginner)

    contents            Content[]      @relation("author")

    subscriptionsBought Subscription[] @relation("bought")
    subscriptionsUsed   Subscription[]

    reactions           Reaction[]

    views               View[]

    notificationsGenerated Notification[] @relation("notificationBy")
    notifications       Notification[] @relation("notificationTo")

    messagesSent        ChatMessage[]  @relation("messagesSent")
    messagesReceived    ChatMessage[]  @relation("messagesReceived")

    confirmed           Content[]       @relation("confirmChange")
    rejected            Content[]       @relation("rejectChange")

    paymentPromises     PaymentPromise[]   @relation("authorPromises")

    mentionedIn         Content[]       @relation("userMention")
    deletedEntities     Entity[]       @relation("entityDelete")

    closedFollowSuggestionsAt DateTime?
}


model View {
    id                  String         @id @default(cuid())
    createdAt           DateTime       @default(now()) @map("created_at")

    userBy              User           @relation(fields: [userById], references: [id])
    userById            String

    content             Content?       @relation(fields: [contentId], references: [id])
    contentId           String?

    entity              Entity?        @relation("entityViews", fields: [entityId], references: [id])
    entityId            String?
}


model Reaction {
    id                  String         @id @default(cuid())
    createdAt           DateTime       @default(now()) @map("created_at")

    userBy              User           @relation(fields: [userById], references: [id])
    userById            String

    content             Content?       @relation(fields: [contentId], references: [id])
    contentId           String?

    entity              Entity?        @relation("entityReactions", fields: [entityId], references: [id])
    entityId            String?

    notifications       Notification[]
}

model Subscription {
  id             String    @id @default(cuid())
  userId         String?
  createdAt      DateTime  @default(now()) @map("created_at")
  boughtByUserId String
  usedAt         DateTime?
  boughtBy       User      @relation("bought", fields: [boughtByUserId], references: [id])
  user           User?     @relation(fields: [userId], references: [id])
  price          Int
  paymentId      String?
  endsAt         DateTime?

  paymentPromises PaymentPromise[]
  promisesCreated Boolean  @default(false)
}


enum PromiseStatus {
  Pending
  Confirmed
  Canceled
}


model PaymentPromise {
  id             String    @id @default(cuid())

  createdAt      DateTime  @default(now()) @map("created_at")

  author         User      @relation("authorPromises", fields: [authorId], references: [id])
  authorId       String

  subscription   Subscription  @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  amount         Float // errores numéricos?

  contentId      String
  content        Content  @relation(fields: [contentId], references: [id])

  status         PromiseStatus  @default(Pending) // true cuando el contenido pasó su período de gracia
}


model ContactEmails {
  id             String    @id @default(cuid())
  mail           String
  createdAt      DateTime  @default(now()) @map("created_at")
}


model Entity {
  id           String          @id
  name         String          @unique @db.VarChar(255)
  protection   EditorStatus    @default(Beginner)
  isPublic     Boolean         @default(false)
  deleted      Boolean         @default(false)
  deletedById  String?
  versions     Content[]
  deletedBy    User?           @relation("entityDelete", fields: [deletedById], references: [id])

  reactions    Reaction[]      @relation("entityReactions")
  views        View[]          @relation("entityViews")

  currentVersionId String?     @unique
  currentVersion Content?  @relation("currentVersion", fields: [currentVersionId], references: [id])

  referencedBy  Reference[]
}

model Reference {
  id                    String    @id
  entityReferencedId    String
  entityReferenced      Entity    @relation(fields: [entityReferencedId], references: [id])

  referencingContentId  String
  referencingContent    Content   @relation(fields: [referencingContentId], references: [id])

  isStrong              Boolean
}

model Content {
  id               String      @id @default(cuid())
  createdAt        DateTime    @default(now()) @map("created_at")
  type             ContentType
  authorId         String
  isDraft          Boolean?    @default(false)
  visible          Boolean     @default(true)
  text             String?
  plainText        String?      @default("")
  compressedText      String      @default("")
  compressedPlainText String      @default("")

  numChars         Int         @default(0)
  numWords         Int         @default(0)
  numNodes         Int         @default(0)
  
  title            String?
  categories       String      @default("[]")
  parentEntityId   String?
  
  undos            Content[]  @relation("undo")

  contentUndone    Content?   @relation("undo", fields: [contentUndoneId], references: [id])
  contentUndoneId  String? 
  reportsVandalism  Boolean?
  reportsOportunism Boolean?

  confirmedBy      User?       @relation("confirmChange", fields: [confirmedById], references: [id])
  confirmedById    String?
  rejectedBy       User?       @relation("rejectChange", fields: [rejectedById], references: [id])
  rejectedById     String?
  confirmedAt      DateTime?
  rejectedAt       DateTime?

  author           User        @relation("author", fields: [authorId], references: [id])
  parentEntity     Entity?     @relation(fields: [parentEntityId], references: [id])
  childrenContents Content[]   @relation("ContentToContent")
  parentContents   Content[]   @relation("ContentToContent")

  reactions        Reaction[]

  views            View[]
  
  charsAdded       Int?
  charsDeleted     Int?
  accCharsAdded    Int?
  contribution     String?
  diff             String?

  rootContentId    String?
  rootContent      Content?     @relation("rootContent", fields: [rootContentId], references: [id])
  rootOf           Content[]    @relation("rootContent")
  
  ancestorContent  Content[]    @relation("ancestorContent")
  childrenTree     Content[]    @relation("ancestorContent")

  notifications    Notification[]

  noAccountVisits  NoAccountVisit[]

  currentVersionOf Entity? @relation("currentVersion")

  claimsAuthorship Boolean @default(true)
  removedAuthorshipAt DateTime?
  
  editPermission   Boolean @default(true)

  paymentPromises  PaymentPromise[]

  stallPaymentUntil  DateTime?

  editMsg          String?

  isContentEdited  Boolean   @default(false)

  usersMentioned  User[]    @relation("userMention")

  uniqueCommentators Int    @default(0)

  references  Reference[]

  searchkeys  String[]

  uniqueViewsCount    Int            @default(0)
  fakeReportsCount    Int            @default(0)
}

enum NotificationType {
  Comment
  CommentToComment
  Reaction
  Follow
  Edit
  Mention
  EditMention
}

model Notification {
  id               String      @id @default(cuid())
  createdAt        DateTime    @default(now()) @map("created_at")
  type             NotificationType

  // Comment, EntityContent, o contenido al que se reaccionó
  content          Content?    @relation(fields: [contentId], references: [id])
  contentId        String?

  reaction         Reaction?   @relation(fields: [reactionId], references: [id])
  reactionId       String?

  userBy           User        @relation("notificationBy", fields: [userById], references: [id])
  userById         String

  userNotified     User        @relation("notificationTo", fields: [userNotifiedId], references: [id])
  userNotifiedId   String

  viewed           Boolean     @default(false)
}


model NoAccountUser {
  id               String      @id @default(cuid())
  createdAt        DateTime    @default(now()) @map("created_at")

  ip               String
  ua               String
  browser          String
  engine           String
  os               String
  device           String
  cpu              String
  isBot            Boolean

  visits           NoAccountVisit[]
}


model NoAccountVisit {
  id               String      @id @default(cuid())
  createdAt        DateTime    @default(now()) @map("created_at")
  user             NoAccountUser  @relation(fields: [userId], references: [id])
  userId           String

  contentId        String
  content          Content  @relation(fields: [contentId], references: [id])
}


model ChatMessage {
  id               String      @id @default(cuid())
  createdAt        DateTime    @default(now()) @map("created_at")
  fromUser         User  @relation("messagesSent", fields: [fromUserId], references: [id])
  fromUserId       String

  toUser           User  @relation("messagesReceived", fields: [toUserId], references: [id])
  toUserId         String

  text             String

  seen             Boolean @default(false)
}

enum EditorStatus {
  Beginner
  Editor
  Administrator
}

enum ContentType {
  Comment
  Post
  FastPost
  EntityContent
  FakeNewsReport
  UndoEntityContent
}