generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model AuthSession {
  key     String @id
  session String
}

model AuthState {
  key   String @id
  state String
}

enum MirrorStatus {
  Dirty
  InProcess
  Sync
  Failed
}

model User {
  did                 String           @id @db.VarChar(255) // https://atproto.com/guides/identity
  handle              String?
  displayName         String?
  avatar              String?
  banner              String?
  email               String?
  description         String?
  hasAccess           Boolean          @default(false) // si tiene o no acceso al período de prueba
  inCA                Boolean          @default(false)
  CAProfile           Record?          @relation("CAProfile", fields: [CAProfileUri], references: [uri])
  CAProfileUri        String?          @unique
  mirrorStatus        MirrorStatus     @default(Dirty) // estado del mirror, usado en atproto-sync
  createdAt           DateTime         @default(now()) @map("created_at")
  editorStatus        EditorStatus     @default(Beginner) // permisos de editor en la wiki
  platformAdmin       Boolean          @default(false) // si tiene acceso o no a /admin
  subscriptionsBought Subscription[]   @relation("bought")
  subscriptionsUsed   Subscription[]
  messagesSent        ChatMessage[]    @relation("messagesSent")
  messagesReceived    ChatMessage[]    @relation("messagesReceived")
  paymentPromises     PaymentPromise[] @relation("authorPromises")
  views               View[]
  records             Record[]
  blobs               Blob[]
  followers           Follow[]
  usedInviteCode      InviteCode?      @relation("invite-code-used")
  recommendCodes      InviteCode[]     @relation("invite-codes-available") // los códigos de invitación que tiene disponibles para usar
  seenTutorial        Boolean          @default(false)
}

model InviteCode {
  code          String    @id @default(cuid())
  usedBy        User?     @relation("invite-code-used", fields: [usedByDid], references: [did])
  usedByDid     String?   @unique
  usedAt        DateTime?
  recommender   User?     @relation("invite-codes-available", fields: [recommenderId], references: [did])
  recommenderId String?   @unique
}

model Subscription {
  id              String           @id @default(cuid())
  userId          String?
  createdAt       DateTime         @default(now()) @map("created_at")
  boughtByUserId  String
  usedAt          DateTime?
  boughtBy        User             @relation("bought", fields: [boughtByUserId], references: [did])
  user            User?            @relation(fields: [userId], references: [did])
  price           Int
  paymentId       String?
  endsAt          DateTime?
  paymentPromises PaymentPromise[]
  promisesCreated Boolean          @default(false)
}

enum PromiseStatus {
  Pending
  Confirmed
  Canceled
}

model PaymentPromise {
  id             String        @id @default(cuid())
  createdAt      DateTime      @default(now()) @map("created_at")
  author         User          @relation("authorPromises", fields: [authorId], references: [did])
  authorId       String
  subscription   Subscription  @relation(fields: [subscriptionId], references: [id])
  subscriptionId String
  amount         Float
  contentUri     String
  status         PromiseStatus @default(Pending) // true cuando el contenido pasó su período de gracia
}

model Topic {
  id                 String            @id
  protection         EditorStatus      @default(Beginner)
  versions           TopicVersion[]
  currentVersion     TopicVersion?     @relation("currentVersion", fields: [currentVersionId], references: [uri])
  currentVersionId   String?           @unique
  referencedBy       Reference[]
  synonyms           String[]
  categories         TopicToCategory[]
  lastSynonymsChange DateTime?
  popularityScore    Int?
  lastEdit           DateTime?
}

model TopicCategory {
  id     String            @id
  topics TopicToCategory[]
  linksA CategoryLink[]    @relation("linksA")
  linksB CategoryLink[]    @relation("linksB")
}

model CategoryLink {
  idCategoryA String
  categoryA   TopicCategory @relation("linksA", fields: [idCategoryA], references: id)
  idCategoryB String
  categoryB   TopicCategory @relation("linksB", fields: [idCategoryB], references: id)

  @@id([idCategoryA, idCategoryB])
}

model TopicToCategory {
  topicId    String
  categoryId String
  topic      Topic         @relation(fields: [topicId], references: [id])
  category   TopicCategory @relation(fields: [categoryId], references: [id])

  @@id([topicId, categoryId])
}

model Record {
  uri                 String          @id @unique
  cid                 String?
  collection          String
  rkey                String
  author              User            @relation(fields: [authorId], references: [did])
  authorId            String
  createdAt           DateTime        @default(now()) @map("created_at")
  content             Content?
  like                Like?
  repost              Repost?
  topicAccept         TopicAccept?
  topicReject         TopicReject?
  follow              Follow?
  dataset             Dataset?
  dataBlock           DataBlock?
  visualization       Visualization?
  visualizationsUsing Visualization[] @relation("visualizationUsesDataset")
  embeddedIn          Record?         @relation("embeddings", fields: [uri], references: [uri])
  embeddedRecords     Record[]        @relation("embeddings")
  record              String?
  likes               Like[]          @relation("likes")
  reposts             Repost[]        @relation("reposts")
  replies             Post[]          @relation("reply")
  rootOf              Post[]          @relation("root")
  accepts             TopicAccept[]   @relation("accepts")
  rejects             TopicReject[]   @relation("rejects")
  views               View[]
  uniqueViewsCount    Int?            @default(0)
  CAProfileOf         User?           @relation("CAProfile")

  lastInThread           Post?   @relation("lastInThread", fields: [lastInThreadId], references: [uri])
  lastInThreadId         String? @unique
  secondToLastInThreadId String? @unique
  secondToLastInThread   Post?   @relation("secondToLastInThread", fields: [secondToLastInThreadId], references: [uri])
}

model Content {
  uri                  String        @id
  record               Record        @relation(fields: [uri], references: [uri])
  text                 String?
  textBlobId           String?
  textBlob             Blob?         @relation(fields: [textBlobId], references: [cid])
  format               String        @default("lexical-compressed")
  numWords             Int?
  topicVersion         TopicVersion?
  article              Article?
  post                 Post?
  references           Reference[]
  lastReferencesUpdate DateTime?
}

model Post {
  uri       String  @id
  content   Content @relation(fields: [uri], references: [uri])
  facets    String?
  embed     String?
  replyToId String?
  replyTo   Record? @relation("reply", fields: [replyToId], references: [uri])
  quote     String?
  rootId    String?
  root      Record? @relation("root", fields: [rootId], references: [uri])

  lastInThread         Record? @relation("lastInThread")
  secondToLastInThread Record? @relation("secondToLastInThread")
}

model Follow {
  uri            String  @id
  record         Record  @relation(fields: [uri], references: [uri])
  userFollowedId String?
  userFollowed   User?   @relation(fields: [userFollowedId], references: [did])
}

model Like {
  uri           String  @id
  record        Record  @relation(fields: [uri], references: [uri])
  likedRecordId String?
  likedRecord   Record? @relation("likes", fields: [likedRecordId], references: [uri])
}

model Repost {
  uri              String  @id
  record           Record  @relation(fields: [uri], references: [uri])
  repostedRecordId String?
  repostedRecord   Record? @relation("reposts", fields: [repostedRecordId], references: [uri])
}

model TopicAccept {
  uri              String  @id
  record           Record  @relation(fields: [uri], references: [uri])
  acceptedRecordId String?
  acceptedRecord   Record? @relation("accepts", fields: [acceptedRecordId], references: [uri])
}

model TopicReject {
  uri              String  @id
  record           Record  @relation(fields: [uri], references: [uri])
  rejectedRecordId String?
  rejectedRecord   Record? @relation("rejects", fields: [rejectedRecordId], references: [uri])
}

model TopicVersion {
  uri              String  @id
  content          Content @relation(fields: [uri], references: [uri])
  title            String?
  topic            Topic   @relation(fields: [topicId], references: [id])
  topicId          String
  message          String  @default("")
  synonyms         String?
  categories       String?
  authorship       Boolean @default(true)
  currentVersionOf Topic?  @relation("currentVersion")
  charsAdded       Int?
  charsDeleted     Int?
  accCharsAdded    Int?
  contribution     String?
  diff             String?
}

model Article {
  uri     String  @id
  content Content @relation(fields: [uri], references: [uri])
  title   String
}

model Dataset {
  uri         String      @id
  record      Record      @relation(fields: [uri], references: [uri])
  columns     String[]
  title       String
  dataBlocks  DataBlock[]
  description String?
}

model Blob {
  cid      String @id @unique
  author   User   @relation(fields: [authorId], references: [did])
  authorId String

  dataBlock DataBlock?
  contentOf Content[]
  previewOf Visualization[]
}

model DataBlock {
  uri       String   @id
  record    Record   @relation(fields: [uri], references: [uri])
  dataset   Dataset? @relation(fields: [datasetId], references: [uri])
  datasetId String?
  format    String
  blob      Blob?    @relation(fields: [blobId], references: [cid])
  blobId    String?  @unique
}

model View {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  userBy    User     @relation(fields: [userById], references: [did])
  userById  String

  recordId String?
  record   Record? @relation(fields: [recordId], references: [uri])
}

model Visualization {
  uri            String  @id
  record         Record  @relation(fields: [uri], references: [uri])
  spec           String
  dataset        Record? @relation("visualizationUsesDataset", fields: [datasetId], references: [uri])
  datasetId      String?
  previewBlobCid String?
  previewBlob    Blob?   @relation(fields: [previewBlobCid], references: [cid])
}

model Reference {
  id                   String        @id @default(uuid())
  type                 ReferenceType
  count                Int           @default(1)
  referencedTopicId    String
  referencedTopic      Topic         @relation(fields: [referencedTopicId], references: [id])
  referencingContentId String
  referencingContent   Content       @relation(fields: [referencingContentId], references: [uri])

  @@unique([referencingContentId, referencedTopicId])
}

enum ReferenceType {
  Strong
  Weak
}

model ChatMessage {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now()) @map("created_at")
  fromUser   User     @relation("messagesSent", fields: [fromUserId], references: [did])
  fromUserId String
  toUser     User     @relation("messagesReceived", fields: [toUserId], references: [did])
  toUserId   String
  text       String
  seen       Boolean  @default(false)
}

enum EditorStatus {
  Beginner
  Editor
  Administrator
}
