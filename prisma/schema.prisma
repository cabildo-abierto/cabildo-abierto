generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model AuthSession {
  key     String @id
  session String
}

model AuthState {
  key   String @id
  state String
}

model User {
    did                 String         @id @db.VarChar(255) // did
    handle             String
    email              String?

    hasAccess          Boolean         @default(false)

    createdAt          DateTime       @default(now()) @map("created_at")

    editorStatus        EditorStatus   @default(Beginner)

    subscriptionsBought Subscription[] @relation("bought")
    subscriptionsUsed   Subscription[]

    messagesSent        ChatMessage[]  @relation("messagesSent")
    messagesReceived    ChatMessage[]  @relation("messagesReceived")

    paymentPromises     PaymentPromise[]   @relation("authorPromises")

    topicVersions       TopicVersion[]

    topicVersionAccepts TopicVersionAccept[]
    topicVersionRejects TopicVersionReject[]

    views               View[]
}




model Subscription {
  id             String    @id @default(cuid())
  userId         String?
  createdAt      DateTime  @default(now()) @map("created_at")
  boughtByUserId String
  usedAt         DateTime?
  boughtBy       User      @relation("bought", fields: [boughtByUserId], references: [did])
  user           User?     @relation(fields: [userId], references: [did])
  price          Int
  paymentId      String?
  endsAt         DateTime?

  paymentPromises PaymentPromise[]
  promisesCreated Boolean  @default(false)
}


enum PromiseStatus {
    Pending
    Confirmed
    Canceled
}


model PaymentPromise {
  id             String    @id @default(cuid())

  createdAt      DateTime  @default(now()) @map("created_at")

  author         User      @relation("authorPromises", fields: [authorId], references: [did])
  authorId       String

  subscription   Subscription  @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  amount         Float // errores numéricos?

  contentUri     String

  status         PromiseStatus  @default(Pending) // true cuando el contenido pasó su período de gracia
}


model Topic {
  id           String          @id
  protection   EditorStatus    @default(Beginner)
  versions     TopicVersion[]
  currentVersion TopicVersion? @relation("currentVersion", fields: [currentVersionId], references: [cid])
  currentVersionId String?      @unique
}


model TopicVersion {
    cid             String    @id @default(cuid())
    uri            String

    title          String?
    text           String
    author         User      @relation(fields: [authorId], references: [did])
    authorId       String

    createdAt      DateTime  @default(now()) @map("created_at")

    topic          Topic     @relation(fields: [topicId], references: [id])
    topicId        String

    message          String  @default("")

    charsAdded       Int?
    charsDeleted     Int?
    accCharsAdded    Int?
    contribution     String?
    diff             String?

    categories       String?
    synonyms         String[]

    authorship       Boolean  @default(true)

    accepts          TopicVersionAccept[]
    rejects          TopicVersionReject[]

    currentVersionOf Topic?   @relation("currentVersion")

    views            View[]
}


model TopicVersionAccept {
    cid              String          @id
    uri              String

    topicVersionId   String
    topicVersion     TopicVersion    @relation(fields: [topicVersionId], references: [cid])

    authorId         String
    author           User            @relation(fields: [authorId], references: [did])

    createdAt        DateTime        @default(now()) @map("created_at")
}


model TopicVersionReject {
    cid              String          @id
    uri              String

    topicVersionId   String
    topicVersion     TopicVersion    @relation(fields: [topicVersionId], references: [cid])

    text             String

    authorId         String
    author           User            @relation(fields: [authorId], references: [did])

    createdAt        DateTime        @default(now()) @map("created_at")
}


model FastPost {
    cid              String    @id
    uri              String
    views            View[]
}


model Article {
    cid              String   @id
    uri              String
    views            View[]
}


model View {
    id               String      @id @default(cuid())
    createdAt        DateTime    @default(now()) @map("created_at")
    type             ViewType
    userBy           User        @relation(fields: [userById], references: [did])
    userById         String

    topicVersionId   String?
    topicVersion     TopicVersion?   @relation(fields: [topicVersionId], references: [cid])

    fastPostId   String?
    fastPost     FastPost?   @relation(fields: [fastPostId], references: [cid])

    articleId   String?
    article     Article?    @relation(fields: [articleId], references: [cid])
}

enum ViewType {
    TopicVersionView
    FastPostView
    ArticleView
}


model ChatMessage {
  id               String      @id @default(cuid())
  createdAt        DateTime    @default(now()) @map("created_at")
  fromUser         User  @relation("messagesSent", fields: [fromUserId], references: [did])
  fromUserId       String

  toUser           User  @relation("messagesReceived", fields: [toUserId], references: [did])
  toUserId         String

  text             String

  seen             Boolean @default(false)
}


enum EditorStatus {
  Beginner
  Editor
  Administrator
}

enum ContentType {
  Comment
  Post
  FastPost
  EntityContent
  FakeNewsReport
  UndoEntityContent
}